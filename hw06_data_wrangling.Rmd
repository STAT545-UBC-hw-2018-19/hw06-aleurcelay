---
title: "hw06_data_wrangling"
author: "Alejandra"
date: "09/11/2018"
output: 
  html_document:
    toc: yes
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

## Data wrangling wrap up 



## 1. Character data

Read and work the exercises in the [Strings chapter](https://r4ds.had.co.nz/strings.html) of R for Data Science.

### 14.2.5 

3. Use `str_length()` and `str_sub()` to extract the middle character from a string. What will you do if the string has an even number of characters?

```{r}
library(tidyverse)
library(stringr)

string1 <- "abc"
string2 <- "abcd"

str_sub(string1, floor((str_length(string1)+1)/2), ceiling((str_length(string1)+1)/2))

str_sub(string2, floor((str_length(string2)+1)/2), ceiling((str_length(string2)+1)/2)) #returns the two middle characters as the string has an even number. 

```


6. Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.

```{r}
st_comma <- function (x, delim = ",") {
  num <- length(x)
  if(num == 0) {
   stop("vector length = 0") #error message when trying with a length 0 vector
  } else if(num == 1) {
    x
  } else if(num == 2) {
    str_c(x[[1]], "and", x[[2]], sep = " ")
  } else {
   str_1 <- str_c(x[seq_len(num - 1)], delim) #all but the last
   str_2 <- str_c("and", x[[num]], sep = " ")
   str_c(c(str_1, str_2), collapse = " ")
  }
}

#st_comma(c()) # as vector is length 0, the function throws an error message "vector length = 0"
st_comma("a") 
st_comma(c("a", "b"))
st_comma(c("a", "b", "c"))
```

### 14.3.1.1 

2. How would you match the sequence `"'\`?

```{r}
str_view("\"'\\", "\"'\\\\")
```

3. What patterns will the regular expression `\..\..\..` match? How would you represent it as a string?

```{r}
str_view("w.x.y.z", "\\..\\..\\..")
```

It matches patterns with a dot followed by a character that repeats three times. 

### 14.3.2.1

1. How would you match the literal string `"$^$"` ?

```{r}
str_view("$^$", "^\\$\\^\\$")
```

2. Given the corpus of common words in `stringr::words`, create regular expressions that find all words that:

* Start with “y”.
* End with “x”
* Are exactly three letters long. (Don’t cheat by using str_length()!)
* Have seven letters or more.

Since the list is long, I used a match argument to show only the matching words.

```{r}
str_view_match <- function(words, pattern) {
    str_view(words, pattern, match=TRUE)
} #function to only show matches

# start with y
str_view_match(words, "^y") 

# end with x
str_view_match(words, "x$")

# have exactly three letters
str_view_match(words, "^...$")

# ≥ 7 letters
str_view_match(words, ".......")
```

### 14.3.3.1

1. Create regular expressions to find all words that:

* Start with a vowel.
* That only contain consonants. (Hint: thinking about matching “not”-vowels.)
* End with ed, but not with eed.
* End with ing or ise.

```{r}
# start with a vowel
str_view_match(words, "^[aeiou]")

# only consonants
str_view_match(words, "^[^aeiou]+$")

# end with ed, but not with eed
str_view_match(words, "^ed$|[^e]ed$")

# end with ing or ise
str_view_match(words, "ing$|ise$")
```

2. Empirically verify the rule “i before e except after c”.

```{r}
str_view_match(words, "([^c]ie|cei)") #rule
str_view_match(words, "(cie)") #exceptions?
```

From the second output we can see there are some exceptions for this rule, such as the words `science` and `society`.


3. Is “q” always followed by a “u”?

```{r}
str_view_match(words, "q[^u]")
```

There were no words in the output, so "q" is always followed by a "u".


4. Write a regular expression that matches a word if it’s probably written in British English, not American English.

```{r}
str_view_match(words, "ise$|our") #ise instead of ize and our instead of or
```


5. Create a regular expression that will match telephone numbers as commonly written in your country

```{r}
phones <- c("(55)32498722", "(778)952-5873")
str_view(phones, "\\(\\d{2}\\)\\d{8}", match = T)
```

The output matches the telephone number as commonly written in Mexico.

### 14.3.4.1 

3. Create regular expressions to find all words that:

* Start with three consonants.
* Have three or more vowels in a row.
* Have two or more vowel-consonant pairs in a row.

```{r}
# start with 3 consonants
str_view_match(words, "^[^aeiou]{3}")

# ≥ 3 vowels in a row
str_view_match(words, "[aeiou]{3,}")

# ≥ 2 vowel-consonant pairs in a row
str_view_match(words, "([aeiou][^aeiou]){2,}")
```


